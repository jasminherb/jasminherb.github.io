---
layout: single
title:  "EarlyStopping Callback & Checkpointer(9) "
---

# 주택가격 예측

출처 : Thebook.io (모두의 딥러닝)

주택 가격 예측하기

주거 유형, 차고, 자재 및 환경에 관한 80개의 서로 다른 속성을 이용해 집의 가격을 예측해 볼 예정인데 

오랜 시간 사람이 일일이 기록하다 보니 빠진 부분도 많고,

집에 따라 어떤 항목은 범위에서 너무 벗어나 있기도 하며, 

또 가격과는 관계가 없는 정보가 포함되어 있기도 합니다. 

실제 현장에서 만나게 되는 이런 류의 데이터를 어떻게 다루어야 하는지 보겠습니다.



![street-5932230_640](https://github.com/jasminherb/jasminherb.github.io/assets/133365586/a48364ae-bf44-4f88-be28-cecc4fcfbb31)


데이터 Type 파악하기

```python
import pandas as pd

# 집 값 데이터를 불러옵니다.
df = pd.read_csv("./data/house_train.csv")

df

df.dtypes

```

1460 rows × 81 columns


Id int64

MSSubClass         int64

MSZoning          object

LotFrontage      float64

LotArea            int64
          
MoSold             int64

YrSold             int64

SaleType          object

SaleCondition     object

SalePrice          int64

Length: 81, dtype: object







결측치가 있는지 알아보는 함수는 isnull()입니다. 

결측치가 모두 몇 개인지 세어 가장 많은 것부터 순서대로 나열한 후 처음 20개만 출력하는 코드는 다음과 같습니다.


```python

df.isnull().sum().sort_values(ascending=False).head(20)

```
![image](https://github.com/jasminherb/jasminherb.github.io/assets/133365586/4ef45033-8455-4b4d-9f59-2b39a274d0d2)


결측치가 많은 항목은 1,460개의 샘플 중에서 1,453개나 비어 있을 만큼 빠진 곳이 많은 것을 확인할 수 있습니다.

get_dummies() 함수를 이용해 카테고리형 변수를 0과 1로 이루어진 변수로 바꾸어 줍니다.

```python
df = pd.get_dummies(df)
```

그리고 결측치를 채워 줍니다. 

결측치를 채워 주는 함수는 판다스의 fillna()입니다. 괄호 안에 df.mean()을 넣어 주면 평균값으로 채워 줍니다.

```python
df = df.fillna(df.mean())
```


이 중에서 우리에게 필요한 정보를 추출해 보겠습니다. 

먼저 데이터 사이의 상관관계를 df_corr 변수에 저장합니다. 

그리고  집 값과 관련이 큰 것부터 순서대로 정렬해 df_corr_ sort 변수에 저장합니다.  

집 값과 관련도가 가장 큰 열 개의 속성들을 출력합니다.


```python

df_corr = df.corr() 
df_corr_sort = df_corr.sort_values('SalePrice', ascending=False)
df_corr_sort['SalePrice'].head(10)

```
![image](https://github.com/jasminherb/jasminherb.github.io/assets/133365586/ecfcd6ac-e1c3-410e-a5e6-9873bfc153fd)



추출된 속성들과 집 값의 관련도를 시각적으로 확인하기 위해 상관도 그래프를 그려 보겠습니다.

```python
cols = ['SalePrice','OverallQual','GrLivArea','GarageCars','GarageArea','TotalBsmtSF']
sns.pairplot(df[cols])
plt.show();

```

![housing](https://github.com/jasminherb/jasminherb.github.io/assets/133365586/3d0fb47e-c6e7-4100-8fb7-bd58a9e1122d)




```python
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split

import matplotlib.pyplot as plt
import seaborn as sns

import pandas as pd
import numpy as np

# 깃허브에 준비된 데이터를 가져옵니다.
!git clone https://github.com/taehojo/data.git

# 집 값 데이터를 불러옵니다.
df = pd.read_csv("./data/house_train.csv")

# 카테고리형 변수를 0과 1로 이루어진 변수로 바꾸어 줍니다.
df = pd.get_dummies(df)

# 결측치를 전체 칼럼의 평균으로 대체해 채워 줍니다.
df = df.fillna(df.mean())

# 데이터 사이의 상관관계를 저장합니다.
df_corr = df.corr()

# 집 값과 관련이 큰 것부터 순서대로 저장합니다.
df_corr_sort = df_corr.sort_values('SalePrice', ascending=False)

# 집 값을 제외한 나머지 열을 저장합니다. 
cols_train = ['OverallQual','GrLivArea','GarageCars','GarageArea','TotalBsmtSF']
X_train_pre = df[cols_train]

# 집 값을 저장합니다.
y = df['SalePrice'].values

# 전체의 80%를 학습셋으로, 20%를 테스트셋으로 지정합니다.
X_train, X_test, y_train, y_test = train_test_split(X_train_pre, y, test_size=0.2)

# 모델의 구조를 설정합니다.
model = Sequential()
model.add(Dense(10, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(30, activation='relu'))
model.add(Dense(40, activation='relu'))
model.add(Dense(1))
model.summary()

# 모델을 실행합니다.
model.compile(optimizer='adam', loss='mean_squared_error')

# 20번 이상 결과가 향상되지 않으면 자동으로 중단되게끔 합니다.
early_stopping_callback = EarlyStopping(monitor='val_loss', patience=20)

# 모델의 이름을 정합니다.
modelpath = "./data/model/Ch15-house.hdf5"

# 최적화 모델을 업데이트하고 저장합니다.
checkpointer = ModelCheckpoint(filepath=modelpath, monitor='val_loss', verbose=0, save_best_only=True)

# 실행 관련 설정을 하는 부분입니다. 전체의 20%를 검증셋으로 설정합니다.
history = model.fit(X_train, y_train, validation_split=0.25, epochs=2000, batch_size=32, callbacks=[early_stopping_callback,checkpointer])

real_prices = []
pred_prices = []
X_num = []

n_iter = 0
Y_prediction = model.predict(X_test).flatten()
for i in range(25):
    real = y_test[i]
    prediction = Y_prediction[i]
    print("실제가격: {:.2f}, 예상가격: {:.2f}".format(real, prediction))
    real_prices.append(real)
    pred_prices.append(prediction)
    n_iter = n_iter + 1
    X_num.append(n_iter)
    
    
plt.plot(X_num, pred_prices, label='predicted price')
plt.plot(X_num, real_prices, label='real price')
plt.legend()
plt.show()    
```
